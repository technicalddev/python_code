# -*- coding: utf-8 -*-
"""Step8-PotentialToPay.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hbiz5MytHMdu1fhjE5CCi7tb77Gg9Oj9

# Authentication and Importing Libraries
"""

!pip install pandas-profiling
!pip install --upgrade 'sqlalchemy<2.0'

# Authenticating credentials

from google.colab import auth,files
auth.authenticate_user()

import gspread
from google.auth import default
creds, _ = default()

gc = gspread.authorize(creds)
# gc = gspread.authorize(GoogleCredentials.get_application_default())

# gauth = GoogleAuth()
# gauth.credentials = GoogleCredentials.get_application_default()
# drive = GoogleDrive(gauth)
from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# Importing all the necessary modules
import pandas as pd
import pandas_profiling
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from pandas.plotting import scatter_matrix
from datetime import datetime,date
import gspread_dataframe as gd


# Visualizations
import matplotlib.cm as cm
# %matplotlib inline

#!pip install dython
#from dython import nominal

!pip install pymysql

#initialize mysql engine
from sqlalchemy import create_engine
import pymysql
engine = create_engine('mysql+pymysql://' + 'admin' + ':' + '1234mONEYTOr' + '@' + '3.108.47.186' + ':3306/' + 'navi_08_09_2023')
engine.connect()

"""# Potential To Pay"""

#Getting the normalised_sigma from Databases
sql_query='select * from normalised_sigma'
normalised_sigma=pd.read_sql_query(sql_query,engine)
normalised_sigma.shape

normalised_sigma.columns,len(normalised_sigma.columns)

#Make a dictionary of final_weights from Step7-Variable importance colab file
final_weights={'Validated income': -0.02932687908812657,
 'Count of previous loans': -0.020488221898549083,
 'annual_rate_of_interest': 0.11808068256812568,
 'current_dpd': 0.010359439909170856,
 'bureau_score': -0.00025189530551778867,
 'principal_outstanding_amount': -0.2547210037712281,
 'bounce_fee_pending': -0.004452194449718909,
 'penal_interest_pending': -0.04789562634207081,
 'Actual DPD (Calculated)': -0.02710853725789937,
 'Days_since_disbursal': 0.11616499982705494,
 'disp_code_NRTP': -0.002035476833515217,
 'disp_code_address_not_found': -0.0016799368548939093,
 'disp_code_connectivity_mode_problem': -0.0009691714365958109,
 'disp_code_paid': 0.006340262065020797,
 'disp_code_phone_not connected': -0.0009975888449583268,
 'disp_code_positive_response': 0.012235540231384168,
 'disp_code_settlement': 0.0010043122546550217,
 'Age': 6.035452356861825e-05,
 'state_name': 0.00507106092560144,
 'gender': 0.0006027358398059513,
 'Max_count_dispositionCode_map': 0.00860900303861853,
 'Last_interaction_sub_type': 0.0006478000661400531,
 'Last_customer_feedback': 0.011824565534571329,
 'DPDSEGMENT': 0.02930907774787074,
 'CibilSegmentation': 0.012991700951999183,
 'IncomeSegmentation': 0.02677193243333883,
 'TimeWeightedTotalPercentPaid': 0.25}
final_weights.keys()

final_weight_bucket={}
for x in final_weights.keys():
  final_weight_bucket[x+"bucket"]=final_weights[x]
final_weight_bucket

potential_to_pay=pd.DataFrame()

for x in final_weight_bucket.keys():
  potential_to_pay[x]=normalised_sigma[x]*final_weight_bucket[x]

potential_to_pay

potential_to_pay["PotentialToPay"]=potential_to_pay[potential_to_pay.columns].sum(axis=1)

potential_to_pay

Absolute_value_max1=potential_to_pay["PotentialToPay"].max()
print(Absolute_value_max1)
Absolute_value_min1=potential_to_pay["PotentialToPay"].min()
print(Absolute_value_min1)

def normalizingdata(x):
  Absolute_value_min=Absolute_value_min1
  Absolute_value_max=Absolute_value_max1
  ScaledValue_min=0
  ScaledValue_max=50
  result=((x-Absolute_value_min)/(Absolute_value_max-Absolute_value_min))*ScaledValue_max
  return result

potential_to_pay["ScaledPotentialToPay"]=potential_to_pay["PotentialToPay"].apply(lambda x:normalizingdata(x))

potential_to_pay["ScaledPotentialToPay"]

def priceWeightCalculator(weight):
  LowerBounds=[40.05,30.99,23.09,16.35,10.77,6.35,3.09,0.99,0.00]
  UpperBounds=[50.27,40.05,30.99,23.09,16.35,10.77,6.35,3.09,0.99]
  PriceWeights=[22.5,16.1,11.5,8.2,5.9,4.2,3.0,2.1,1.4]
  for i in range(len(PriceWeights)):
    if weight< UpperBounds[i] and weight>= LowerBounds[i]:
      priceFactor = PriceWeights[i]
  return priceFactor

potential_to_pay["pricePercent"]=potential_to_pay["ScaledPotentialToPay"].apply(lambda x:priceWeightCalculator(x))
potential_to_pay["pricePercent"]/=100
potential_to_pay['loan_account_id']=normalised_sigma['loan_account_id']
potential_to_pay['account_number']=normalised_sigma['account_number']

potential_to_pay

potential_to_pay.to_csv("potential_to_pay.csv")

potential_to_pay.to_sql("potentialToPay",con=engine, if_exists='replace',index=False)

"""End of Potential to Pay"""

